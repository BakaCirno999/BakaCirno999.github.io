https://leetcode.cn/problems/subsets/



![8096a43a-ddf1-4c5d-bf47-78a510811de4](file:///C:/Users/22232/Pictures/Typedown/8096a43a-ddf1-4c5d-bf47-78a510811de4.png)



求一个集合的所有子集，已知一个集合的非空子集个数是 2**n - 1

集合 {1, 2, 3, 4} 的非空子集分别为

{1}                                      1位

{1, 2} {1, 3} {1, 4}             2位

{1, 2, 3} {1, 2, 4} {1, 3, 4} 3位

{1, 2, 3, 4}                          4位

{2}                                       1位

{2, 3} {2, 4}                         2位

{2, 3, 4}                                3位

{3}                                        1位

{3, 4}                                    2位

{4}                                        1位



2**4 - 1 = 15个

现使用程序来求出数组所有子集，并列出，不论顺序

由子集排列可知，我们可以按照**元素个数从少到多**、**元素大小从小到大**的方式进行**排列**

则有很通俗的方式，**全排列**，由下列程序易看出，想要求得元素个数最大为 n 时的所有子集，则需要进行 n 阶循环

上面讲的思想其实是**广度优先**的思想，实现起来麻烦一点，因为需要保存**当前元素个数为 n 的所有子集**的状态

由于使用的是深度优先搜索，所以 dfs 程序的输出如下。

![4d3e4a1c-b0ae-4ed6-97b4-6e7b73239109](file:///C:/Users/22232/Pictures/Typedown/4d3e4a1c-b0ae-4ed6-97b4-6e7b73239109.png)

```c++
#include<bits/stdc++.h> 
using namespace std;

int main()    
    vector<int> arr = {1, 2, 3, 4};
    vector<vector<int>> res;
    vector<int> nums;
    // 当子集元素个数最大为1时
    /*
    for(int i = 0; i < 4; i++){
        nums.push_back(arr[i]);
        res.push_back(nums);
        nums.pop_back();
    }
    */
    // 当子集元素个数最大为2时
    /*
    for(int i = 0; i < 4; i++){
        nums.push_back(arr[i]);
        res.push_back(nums);
        for(int j = i+1; j < 4; j++){
            nums.push_back(nums[j]);
            res.push_back(nums);
            nums.pop_back();
        }
        nums.pop_back();
    }
    */
    // 当子集元素个数最大为3时
    for(int i = 0; i < 4; i++){
        nums.push_back(arr[i]);
        res.push_back(nums);
        for(int j = i+1; j < 4; j++){
            nums.push_back(nums[j]);
            res.push_back(nums);
            for(int k = j+1; k < 4; k++){
                nums.push_back(nums[k]);
                res.push_back(nums);
                nums.pop_back();
            }
            nums.pop_back();
        }
        nums.pop_back();
    }
    for(auto vec : res){
        for(auto num : vec){
            cout<<num<<' ';
        }
        cout<<endl;
    }
    return 0
}
```



对于上述程序，每多一个元素，就多一层循环，由此，我们可以利用调用方程的方式来代替子循环的实现，即递归



```c++
#include<bits/stdc++.h>
using namespace std;

void dfs(vector<vector<int>> &res, vector<int> &nums, vector<int> &arr, int n){
    for(int i = n; i < arr.size(); i++){
        nums.push_back(arr[i]);
        res.push_back(nums);
        dfs(res, nums, arr, i+1);
        nums.pop_back();
    }
}

int main(){
    vector<int> arr = {1, 2, 3, 4};
    vector<vector<int>> res;
    vector<int> nums;
    dfs(res, nums, arr, 0);

    for(auto vec : res){
        for(auto num : vec){
            cout<<num<<' ';
        }
        cout<<endl;
    }
    return 0;
}
```

![06a0bf64-ab24-41cc-a825-4384cb00360f](file:///C:/Users/22232/Pictures/Typedown/06a0bf64-ab24-41cc-a825-4384cb00360f.png)





https://leetcode.cn/problems/the-number-of-beautiful-subsets/

![ef9692a8-a441-4d96-8770-540b283f102c](file:///C:/Users/22232/Pictures/Typedown/ef9692a8-a441-4d96-8770-540b283f102c.png)


